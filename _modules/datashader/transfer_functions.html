
<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>datashader.transfer_functions â€” Datashader v0.14.0</title>
<!-- Loaded before other Sphinx assets -->
<link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet"/>
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet"/>
<link href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css" rel="stylesheet"/>
<link as="font" crossorigin="" href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2"/>
<link as="font" crossorigin="" href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css">
<link href="../../_static/togglebutton.css" rel="stylesheet" type="text/css">
<link href="../../_static/mystnb.css" rel="stylesheet" type="text/css">
<link href="../../_static/graphviz.css" rel="stylesheet" type="text/css">
<link href="../../_static/copybutton.css" rel="stylesheet" type="text/css">
<link href="../../_static/nbsite.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/css/custom.css" rel="stylesheet" type="text/css"/>
<!-- Pre-loaded scripts that we'll load fully later -->
<link as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf" rel="preload"/>
<script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
<script src="../../_static/jquery.js"></script>
<script src="../../_static/underscore.js"></script>
<script src="../../_static/doctools.js"></script>
<script src="../../_static/clipboard.min.js"></script>
<script src="../../_static/copybutton.js"></script>
<script>let toggleHintShow = 'Click to show';</script>
<script>let toggleHintHide = 'Click to hide';</script>
<script>let toggleOpenOnPrint = 'true';</script>
<script src="../../_static/togglebutton.js"></script>
<script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
<link href="../../_static/favicon.ico" rel="shortcut icon">
<link href="../../about.html" rel="author" title="About these documents"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="None" name="docsearch:language"/>
<!-- Google Analytics -->
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-154795830-1', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>
</link></link></link></link></link></link></head>
<body data-offset="60" data-spy="scroll" data-target="#bd-toc-nav">
<div class="container-fluid" id="banner"></div>
<nav class="navbar navbar-dark navbar-expand-lg bg-dark fixed-top bd-navbar" id="navbar-main"><div class="container-xl">
<div id="navbar-start">
<a class="navbar-brand" href="../../index.html">
<img alt="logo" class="logo" src="../../_static/logo_horizontal.svg"/>
</a>
</div>
<button aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#navbar-collapsible" data-toggle="collapse" type="button">
<span class="navbar-toggler-icon"></span>
</button>
<div class="col-lg-9 collapse navbar-collapse" id="navbar-collapsible">
<div class="mr-auto" id="navbar-center">
<div class="navbar-center-item">
<ul class="navbar-nav" id="navbar-main-elements">
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../index.html">
  Introduction
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../getting_started/index.html">
  Getting Started
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../user_guide/index.html">
  User Guide
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../topics/index.html">
  Topics
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../api.html">
  API
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../FAQ.html">
  FAQ
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../about.html">
  About
 </a>
</li>
</ul>
</div>
</div>
<div id="navbar-end">
<div class="navbar-end-item">
<ul aria-label="Icon Links" class="navbar-nav" id="navbar-icon-links">
<li class="nav-item">
<a class="nav-link" href="https://github.com/holoviz/datashader" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
<label class="sr-only">GitHub</label></a>
</li>
<li class="nav-item">
<a class="nav-link" href="https://twitter.com/datashader" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
<label class="sr-only">Twitter</label></a>
</li>
<li class="nav-item">
<a class="nav-link" href="https://discourse.holoviz.org/c/datashader/" rel="noopener" target="_blank" title="Discourse"><span><i class="fab fa-discourse"></i></span>
<label class="sr-only">Discourse</label></a>
</li>
<li class="nav-item">
<a class="nav-link" href="https://holoviz.org/" rel="noopener" target="_blank" title="HoloViz"><img alt="HoloViz" class="icon-link-image" src="../../_static/holoviz-icon-white.svg"/></a>
</li>
</ul>
</div>
</div>
</div>
</div>
</nav>
<div class="container-xl">
<div class="row">
<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="col-12 col-md-2 bd-sidebar"><form action="../../search.html" class="bd-search d-flex align-items-center" method="get">
<i class="icon fas fa-search"></i>
<input aria-label="Search the docs ..." autocomplete="off" class="form-control" id="search-input" name="q" placeholder="Search the docs ..." type="search"/>
</form><nav aria-label="Main navigation" class="bd-links" id="bd-docs-nav">
<div class="bd-toc-item active">
</div>
</nav>
</div>
<div class="d-none d-xl-block col-xl-2 bd-toc">
</div>
<main class="col-12 col-md-10 col-xl-8 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
<div>
<h1>Source code for datashader.transfer_functions</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterator</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>
<span class="kn">import</span> <span class="nn">toolz</span> <span class="k">as</span> <span class="nn">tz</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="kn">from</span> <span class="nn">PIL.Image</span> <span class="kn">import</span> <span class="n">fromarray</span>

<span class="kn">from</span> <span class="nn">datashader.colors</span> <span class="kn">import</span> <span class="n">rgb</span><span class="p">,</span> <span class="n">Sets1to3</span>
<span class="kn">from</span> <span class="nn">datashader.composite</span> <span class="kn">import</span> <span class="n">composite_op_lookup</span><span class="p">,</span> <span class="n">over</span><span class="p">,</span> <span class="n">validate_operator</span>
<span class="kn">from</span> <span class="nn">datashader.utils</span> <span class="kn">import</span> <span class="n">nansum_missing</span><span class="p">,</span> <span class="n">ngjit</span><span class="p">,</span> <span class="n">orient_array</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cupy</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="n">cupy</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'Image'</span><span class="p">,</span> <span class="s1">'stack'</span><span class="p">,</span> <span class="s1">'shade'</span><span class="p">,</span> <span class="s1">'set_background'</span><span class="p">,</span> <span class="s1">'spread'</span><span class="p">,</span> <span class="s1">'dynspread'</span><span class="p">]</span>


<div class="viewcode-block" id="Image"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.Image">[docs]</a><span class="k">class</span> <span class="nc">Image</span><span class="p">(</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">70</span>
    <span class="n">border</span><span class="o">=</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">to_pil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">'lower'</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="n">cupy</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">'lower'</span> <span class="k">else</span> <span class="n">data</span>
        <span class="k">return</span> <span class="n">fromarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="s1">'RGBA'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_bytesio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">'png'</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">'lower'</span><span class="p">):</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_pil</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fp</span>

    <span class="k">def</span> <span class="nf">_repr_png_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Supports rich PNG display in a Jupyter notebook"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pil</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_png_</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Supports rich HTML display in a Jupyter notebook"""</span>
        <span class="c1"># imported here to avoid depending on these packages unless actually used</span>
        <span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
        <span class="kn">from</span> <span class="nn">base64</span> <span class="kn">import</span> <span class="n">b64encode</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_pil</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">'png'</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="s2">"""&lt;img style="margin: auto; border:"""</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"""px solid" """</span> <span class="o">+</span> \
            <span class="sd">"""src='data:image/png;base64,{0}'/&gt;"""</span><span class="o">.</span>\
                <span class="nb">format</span><span class="p">(</span><span class="n">b64encode</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">'utf-8'</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">h</span></div>



<span class="k">class</span> <span class="nc">Images</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A list of HTML-representable objects to display in a table.</span>
<span class="sd">    Primarily intended for Image objects, but could be anything</span>
<span class="sd">    that has _repr_html_.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">images</span><span class="p">):</span>
        <span class="sd">"""Makes an HTML table from a list of HTML-representable arguments."""</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s2">"_repr_html_"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">images</span> <span class="o">=</span> <span class="n">images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the number of columns to use in the HTML table.</span>
<span class="sd">        Returns self for convenience.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="o">=</span><span class="n">n</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Supports rich display in a Jupyter notebook, using an HTML table"""</span>
        <span class="n">htmls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">col</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">tr</span><span class="o">=</span><span class="s2">"""&lt;tr style="background-color:white"&gt;"""</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">:</span>
            <span class="n">label</span><span class="o">=</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s2">"name"</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">""</span>

            <span class="n">htmls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"""&lt;td style="text-align: center"&gt;&lt;b&gt;"""</span> <span class="o">+</span> <span class="n">label</span> <span class="o">+</span>
                         <span class="sd">"""&lt;/b&gt;&lt;br&gt;&lt;br&gt;{0}&lt;/td&gt;"""</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">_repr_html_</span><span class="p">()))</span>
            <span class="n">col</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">col</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
                <span class="n">col</span><span class="o">=</span><span class="mi">0</span>
                <span class="n">htmls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"&lt;/tr&gt;"</span><span class="o">+</span><span class="n">tr</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">"""&lt;table style="width:100%; text-align: center"&gt;&lt;tbody&gt;"""</span><span class="o">+</span> <span class="n">tr</span> <span class="o">+</span>\
               <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">htmls</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"""&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;"""</span>



<div class="viewcode-block" id="stack"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.stack">[docs]</a><span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="o">*</span><span class="n">imgs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Combine images together, overlaying later images onto earlier ones.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imgs : iterable of Image</span>
<span class="sd">        The images to combine.</span>
<span class="sd">    how : str, optional</span>
<span class="sd">        The compositing operator to combine pixels. Default is `'over'`.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">imgs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"No images passed in"</span><span class="p">)</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">imgs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Expected `Image`, got: `</span><span class="si">{0}</span><span class="s2">`"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">shapes</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">shape</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The stacked images must have the same shape."</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">composite_op_lookup</span><span class="p">[</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'how'</span><span class="p">,</span> <span class="s1">'over'</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">imgs</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="o">*</span><span class="n">imgs</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">'outer'</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tz</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">tz</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">imgs</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">eq_hist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">256</span><span class="o">*</span><span class="mi">256</span><span class="p">):</span>
    <span class="sd">"""Return a numpy array after histogram equalization.</span>

<span class="sd">    For use in `shade`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">    mask : ndarray, optional</span>
<span class="sd">       Boolean array of missing points. Where True, the output will be `NaN`.</span>
<span class="sd">    nbins : int, optional</span>
<span class="sd">        Maximum number of bins to use. If data is of type boolean or integer</span>
<span class="sd">        this will determine when to switch from exact unique value counts to</span>
<span class="sd">        a binned histogram.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is adapted from the implementation in scikit-image [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] http://scikit-image.org/docs/stable/api/skimage.exposure.html#equalize-hist</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">from</span><span class="o">.</span><span class="n">_cuda_utils</span> <span class="kn">import</span> <span class="nn">interp</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"data must be an ndarray"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span>

    <span class="n">data2</span> <span class="o">=</span> <span class="n">data</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>

    <span class="c1"># Run more accurate value counting if data is of boolean or integer type</span>
    <span class="c1"># and unique value array is smaller than nbins.</span>
    <span class="k">if</span> <span class="n">data2</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">data2</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data2</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">nbins</span><span class="p">):</span>
        <span class="n">values</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">values</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="n">vmax</span><span class="o">-</span><span class="n">vmin</span>
        <span class="n">bin_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">interval</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'uint64'</span><span class="p">)</span>
        <span class="n">hist</span><span class="p">[</span><span class="n">values</span><span class="o">-</span><span class="n">vmin</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">bin_centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">cdf</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
    <span class="n">cdf</span> <span class="o">=</span> <span class="n">cdf</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">cdf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bin_centers</span><span class="p">,</span> <span class="n">cdf</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">out</span><span class="p">),</span> <span class="n">data2</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>



<span class="n">_interpolate_lookup</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'log'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">d</span><span class="p">)),</span>
                       <span class="s1">'cbrt'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">),</span>
                       <span class="s1">'linear'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span>
                       <span class="s1">'eq_hist'</span><span class="p">:</span> <span class="n">eq_hist</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">_normalize_interpolate_how</span><span class="p">(</span><span class="n">how</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">how</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">how</span>
    <span class="k">elif</span> <span class="n">how</span> <span class="ow">in</span> <span class="n">_interpolate_lookup</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_interpolate_lookup</span><span class="p">[</span><span class="n">how</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Unknown interpolation method: </span><span class="si">{0}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">how</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_rescale_discrete_levels</span><span class="p">(</span><span class="n">discrete_levels</span><span class="p">,</span> <span class="n">span</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">discrete_levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"interpolator did not return a valid discrete_levels"</span><span class="p">)</span>

    <span class="c1"># Straight line y = mx + c through (2, 1.5) and (100, 1) where</span>
    <span class="c1"># x is number of discrete_levels and y is lower span limit.</span>
    <span class="n">m</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">/</span><span class="mf">98.0</span>  <span class="c1"># (y[1] - y[0]) / (x[1] - x[0])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span>  <span class="c1"># y[0] - m*x[0]</span>
    <span class="n">multiple</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="n">discrete_levels</span> <span class="o">+</span> <span class="n">c</span>

    <span class="k">if</span> <span class="n">multiple</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">lower_span</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">multiple</span><span class="o">*</span><span class="p">(</span><span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">span</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower_span</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">span</span>


<span class="k">def</span> <span class="nf">_interpolate</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">min_alpha</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">rescale_discrete_levels</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">._cuda_utils</span> <span class="kn">import</span> <span class="n">masked_clip_2d</span><span class="p">,</span> <span class="n">interp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">._cpu_utils</span> <span class="kn">import</span> <span class="n">masked_clip_2d</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span>

    <span class="k">if</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"agg must be 2D"</span><span class="p">)</span>
    <span class="n">interpolater</span> <span class="o">=</span> <span class="n">_normalize_interpolate_how</span><span class="p">(</span><span class="n">how</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">orient_array</span><span class="p">(</span><span class="n">agg</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Compute mask</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">'u'</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">data</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Handle case where everything is masked out</span>
    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                              <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
                     <span class="n">dims</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># Handle offset / clip</span>
    <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">masked_clip_2d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">*</span><span class="n">span</span><span class="p">)</span>

    <span class="c1"># If log/cbrt, could case to float64 right away</span>
    <span class="c1"># If linear, can keep current type</span>
    <span class="n">data</span> <span class="o">-=</span> <span class="n">offset</span>

    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">"ignore"</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s2">"ignore"</span><span class="p">):</span>
        <span class="c1"># Transform data (log, eq_hist, etc.)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">interpolater</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">discrete_levels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">discrete_levels</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># Transform span</span>
        <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">masked_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">span</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">masked_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">masked_data</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rescale_discrete_levels</span><span class="p">:</span>  <span class="c1"># Only valid for how='eq_hist'</span>
                <span class="n">span</span> <span class="o">=</span> <span class="n">_rescale_discrete_levels</span><span class="p">(</span><span class="n">discrete_levels</span><span class="p">,</span> <span class="n">span</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">'eq_hist'</span><span class="p">:</span>
                <span class="c1"># For eq_hist to work with span, we'd need to compute the histogram</span>
                <span class="c1"># only on the specified span's range.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"span is not (yet) valid to use with eq_hist"</span><span class="p">)</span>

            <span class="n">span</span> <span class="o">=</span> <span class="n">interpolater</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">):</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">rspan</span><span class="p">,</span> <span class="n">gspan</span><span class="p">,</span> <span class="n">bspan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">cmap</span><span class="p">))))</span>
        <span class="n">span</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">cmap</span><span class="p">))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">rspan</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">gspan</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">bspan</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">rgba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">rgb</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">aspan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">span</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">aspan</span><span class="p">))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">color</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">color</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">color</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">aspan</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">rgba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">cmap</span><span class="p">):</span>
        <span class="c1"># Assume callable is matplotlib colormap</span>
        <span class="n">scaled_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># Convert cupy array to numpy before passing to matplotlib colormap</span>
            <span class="n">scaled_data</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">)</span>

        <span class="n">rgba</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">rgba</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Expected `cmap` of `matplotlib.colors.Colormap`, "</span>
                        <span class="s2">"`list`, `str`, or `tuple`; got: '</span><span class="si">{0}</span><span class="s2">'"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cmap</span><span class="p">)))</span>

    <span class="n">img</span> <span class="o">=</span> <span class="n">rgba</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Convert cupy array to numpy for final image</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_colorize</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">color_key</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">min_alpha</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">color_baseline</span><span class="p">,</span> <span class="n">rescale_discrete_levels</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"agg must be 3D"</span><span class="p">)</span>

    <span class="n">cats</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">cats</span><span class="p">):</span> <span class="c1"># No categories and therefore no data; return an empty image</span>
        <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">coords</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">([</span>
                         <span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
                         <span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">color_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Color key must be provided, with at least as many "</span> <span class="o">+</span>
                         <span class="s2">"colors as there are categorical fields"</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">color_key</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">color_key</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cats</span><span class="p">,</span> <span class="n">color_key</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color_key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cats</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Insufficient colors provided (</span><span class="si">{}</span><span class="s2">) for the categorical fields available (</span><span class="si">{}</span><span class="s2">)"</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">color_key</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">cats</span><span class="p">)))</span>

    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">rgb</span><span class="p">(</span><span class="n">color_key</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cats</span><span class="p">]</span>
    <span class="n">rs</span><span class="p">,</span> <span class="n">gs</span><span class="p">,</span> <span class="n">bs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">colors</span><span class="p">))</span>

    <span class="c1"># Reorient array (transposing the category dimension first)</span>
    <span class="n">agg_t</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span><span class="o">+</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">orient_array</span><span class="p">(</span><span class="n">agg_t</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
    <span class="n">color_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># subtract color_baseline if needed</span>
    <span class="n">baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">color_data</span><span class="p">)</span> <span class="k">if</span> <span class="n">color_baseline</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">color_baseline</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">baseline</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">color_data</span> <span class="o">-=</span> <span class="n">baseline</span>
        <span class="k">elif</span> <span class="n">baseline</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">color_data</span> <span class="o">+=</span> <span class="o">-</span><span class="n">baseline</span>
        <span class="k">if</span> <span class="n">color_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">'u'</span> <span class="ow">and</span> <span class="n">color_baseline</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color_data</span><span class="p">[</span><span class="n">color_data</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>

    <span class="n">color_total</span> <span class="o">=</span> <span class="n">nansum_missing</span><span class="p">(</span><span class="n">color_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># dot does not handle nans, so replace with zeros</span>
    <span class="n">color_data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># zero-count pixels will be 0/0, but it's safe to ignore that when dividing</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_data</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span><span class="o">/</span><span class="n">color_total</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_data</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span><span class="o">/</span><span class="n">color_total</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_data</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span><span class="o">/</span><span class="n">color_total</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># special case -- to give an appropriate color when min_alpha != 0 and data=0,</span>
    <span class="c1"># take avg color of all non-nan categories</span>
    <span class="n">color_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">cmask_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">color_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_mask</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span><span class="o">/</span><span class="n">cmask_sum</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_mask</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span><span class="o">/</span><span class="n">cmask_sum</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_mask</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span><span class="o">/</span><span class="n">cmask_sum</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="n">missing_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">color_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">missing_colors</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">missing_colors</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">missing_colors</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">total</span> <span class="o">=</span> <span class="n">nansum_missing</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_interpolate_alpha</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">min_alpha</span><span class="p">,</span> <span class="n">rescale_discrete_levels</span><span class="p">)</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Convert cupy array to numpy for final image</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                 <span class="n">dims</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                 <span class="n">coords</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">([</span>
                     <span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
                     <span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
                 <span class="p">]),</span>
                 <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_interpolate_alpha</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">min_alpha</span><span class="p">,</span> <span class="n">rescale_discrete_levels</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">._cuda_utils</span> <span class="kn">import</span> <span class="n">interp</span><span class="p">,</span> <span class="n">masked_clip_2d</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">._cpu_utils</span> <span class="kn">import</span> <span class="n">masked_clip_2d</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span>

    <span class="c1"># if span is provided, use it, otherwise produce a span based off the</span>
    <span class="c1"># min/max of the data</span>
    <span class="k">if</span> <span class="n">span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">'u'</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">|</span> <span class="p">(</span><span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># If at least one element is not masked, use the minimum as the offset</span>
            <span class="c1"># otherwise the offset remains at zero</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">total</span><span class="p">[</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">a_scaled</span> <span class="o">=</span> <span class="n">_normalize_interpolate_how</span><span class="p">(</span><span class="n">how</span><span class="p">)(</span><span class="n">total</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">discrete_levels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a_scaled</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">a_scaled</span><span class="p">,</span> <span class="n">discrete_levels</span> <span class="o">=</span> <span class="n">a_scaled</span>

        <span class="c1"># All-NaN objects (e.g. chunks of arrays with no data) are valid in Datashader</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">np</span><span class="o">.</span><span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="sa">r</span><span class="s1">'All-NaN (slice|axis) encountered'</span><span class="p">)</span>
            <span class="n">norm_span</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a_scaled</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a_scaled</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span>

        <span class="k">if</span> <span class="n">rescale_discrete_levels</span><span class="p">:</span>  <span class="c1"># Only valid for how='eq_hist'</span>
            <span class="n">norm_span</span> <span class="o">=</span> <span class="n">_rescale_discrete_levels</span><span class="p">(</span><span class="n">discrete_levels</span><span class="p">,</span> <span class="n">norm_span</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">'eq_hist'</span><span class="p">:</span>
            <span class="c1"># For eq_hist to work with span, we'll need to compute the histogram</span>
            <span class="c1"># only on the specified span's range.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"span is not (yet) valid to use with eq_hist"</span><span class="p">)</span>
        <span class="c1"># even in fixed-span mode cells with 0 should remain fully transparent</span>
        <span class="c1"># i.e. a 0 will be fully transparent, but any non-zero number will</span>
        <span class="c1"># be clipped to the span range and have min-alpha applied</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">total</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">'u'</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">|</span> <span class="p">(</span><span class="n">total</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">masked_clip_2d</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">*</span><span class="n">span</span><span class="p">)</span>

        <span class="n">a_scaled</span> <span class="o">=</span> <span class="n">_normalize_interpolate_how</span><span class="p">(</span><span class="n">how</span><span class="p">)(</span><span class="n">total</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a_scaled</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">a_scaled</span> <span class="o">=</span> <span class="n">a_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Ignore discrete_levels</span>

        <span class="n">norm_span</span> <span class="o">=</span> <span class="n">_normalize_interpolate_how</span><span class="p">(</span><span class="n">how</span><span class="p">)([</span><span class="mi">0</span><span class="p">,</span> <span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm_span</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">norm_span</span> <span class="o">=</span> <span class="n">norm_span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Ignore discrete_levels</span>

    <span class="c1"># Interpolate the alpha values</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">a_scaled</span><span class="p">,</span> <span class="n">array</span><span class="p">(</span><span class="n">norm_span</span><span class="p">),</span> <span class="n">array</span><span class="p">([</span><span class="n">min_alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="p">]),</span>
               <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_apply_discrete_colorkey</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">color_key</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">color_baseline</span><span class="p">):</span>
    <span class="c1"># use the same approach as 3D case</span>

    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">cupy</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">np</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"agg must be 2D"</span><span class="p">)</span>

    <span class="c1"># validate color_key</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">color_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">color_key</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Color key must be provided as a dictionary"</span><span class="p">)</span>

    <span class="n">agg_data</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">data</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg_data</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="n">agg_data</span> <span class="o">=</span> <span class="n">agg_data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

    <span class="n">cats</span> <span class="o">=</span> <span class="n">color_key</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">rgb</span><span class="p">(</span><span class="n">color_key</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cats</span><span class="p">]</span>
    <span class="n">rs</span><span class="p">,</span> <span class="n">gs</span><span class="p">,</span> <span class="n">bs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">colors</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">agg_data</span><span class="p">)</span> <span class="o">*</span> <span class="n">module</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">module</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">module</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">module</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="n">r2</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">module</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">g2</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">module</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">module</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cats</span><span class="p">):</span>
        <span class="n">value_mask</span> <span class="o">=</span> <span class="n">agg_data</span> <span class="o">==</span> <span class="n">c</span>
        <span class="n">data</span><span class="p">[</span><span class="n">value_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">r2</span><span class="p">[</span><span class="n">value_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">rs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">g2</span><span class="p">[</span><span class="n">value_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">b2</span><span class="p">[</span><span class="n">value_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">bs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">color_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># subtract color_baseline if needed</span>
    <span class="n">baseline</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">color_data</span><span class="p">)</span> <span class="k">if</span> <span class="n">color_baseline</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">color_baseline</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">baseline</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">color_data</span> <span class="o">-=</span> <span class="n">baseline</span>
        <span class="k">elif</span> <span class="n">baseline</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">color_data</span> <span class="o">+=</span> <span class="o">-</span><span class="n">baseline</span>
        <span class="k">if</span> <span class="n">color_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">'u'</span> <span class="ow">and</span> <span class="n">color_baseline</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color_data</span><span class="p">[</span><span class="n">color_data</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">color_data</span><span class="p">[</span><span class="n">module</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">color_data</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">r</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">r2</span>
        <span class="n">g</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">g2</span>
        <span class="n">b</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">b2</span>

    <span class="n">missing_colors</span> <span class="o">=</span> <span class="n">color_data</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">missing_colors</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">missing_colors</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">missing_colors</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="c1"># alpha channel</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Convert cupy array to numpy for final image</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                 <span class="n">dims</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                 <span class="n">coords</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
                 <span class="n">name</span><span class="o">=</span><span class="n">name</span>
                 <span class="p">)</span>


<div class="viewcode-block" id="shade"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.shade">[docs]</a><span class="k">def</span> <span class="nf">shade</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="p">[</span><span class="s2">"lightblue"</span><span class="p">,</span> <span class="s2">"darkblue"</span><span class="p">],</span> <span class="n">color_key</span><span class="o">=</span><span class="n">Sets1to3</span><span class="p">,</span>
          <span class="n">how</span><span class="o">=</span><span class="s1">'eq_hist'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span> <span class="n">min_alpha</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">color_baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale_discrete_levels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">"""Convert a DataArray to an image by choosing an RGBA pixel color for each value.</span>

<span class="sd">    Requires a DataArray with a single data dimension, here called the</span>
<span class="sd">    "value", indexed using either 2D or 3D coordinates.</span>

<span class="sd">    For a DataArray with 2D coordinates, the RGB channels are computed</span>
<span class="sd">    from the values by interpolated lookup into the given colormap</span>
<span class="sd">    ``cmap``.  The A channel is then set to the given fixed ``alpha``</span>
<span class="sd">    value for all non-zero values, and to zero for all zero values.</span>
<span class="sd">    A dictionary ``color_key`` that specifies categories (values in ``agg``)</span>
<span class="sd">    and corresponding colors can be provided to support discrete coloring</span>
<span class="sd">    2D aggregates, i.e aggregates with a single category per pixel,</span>
<span class="sd">    with no mixing. The A channel is set the given ``alpha`` value for all</span>
<span class="sd">    pixels in the categories specified in ``color_key``, and to zero otherwise.</span>

<span class="sd">    DataArrays with 3D coordinates are expected to contain values</span>
<span class="sd">    distributed over different categories that are indexed by the</span>
<span class="sd">    additional coordinate. Such an array would reduce to the</span>
<span class="sd">    2D-coordinate case if collapsed across the categories (e.g. if one</span>
<span class="sd">    did ``aggc.sum(dim='cat')`` for a categorical dimension ``cat``).</span>
<span class="sd">    The RGB channels for the uncollapsed, 3D case are mixed from separate</span>
<span class="sd">    values over all categories. They are computed by averaging the colors</span>
<span class="sd">    in the provided ``color_key`` (with one color per category),</span>
<span class="sd">    weighted by the array's value for that category.</span>
<span class="sd">    The A channel is then computed from the array's total value</span>
<span class="sd">    collapsed across all categories at that location, ranging from the</span>
<span class="sd">    specified ``min_alpha`` to the maximum alpha value (255).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    agg : DataArray</span>
<span class="sd">    cmap : list of colors or matplotlib.colors.Colormap, optional</span>
<span class="sd">        The colormap to use for 2D agg arrays. Can be either a list of</span>
<span class="sd">        colors (specified either by name, RGBA hexcode, or as a tuple</span>
<span class="sd">        of ``(red, green, blue)`` values.), or a matplotlib colormap</span>
<span class="sd">        object.  Default is ``["lightblue", "darkblue"]``.</span>
<span class="sd">    color_key : dict or iterable</span>
<span class="sd">        The colors to use for a categorical agg array. In 3D case, it can be</span>
<span class="sd">        either a ``dict`` mapping from field name to colors, or an</span>
<span class="sd">        iterable of colors in the same order as the record fields,</span>
<span class="sd">        and including at least that many distinct colors. In 2D case,</span>
<span class="sd">        ``color_key`` must be a ``dict`` where all keys are categories,</span>
<span class="sd">        and values are corresponding colors. Number of categories does not</span>
<span class="sd">        necessarily equal to the number of unique values in the agg DataArray.</span>
<span class="sd">    how : str or callable, optional</span>
<span class="sd">        The interpolation method to use, for the ``cmap`` of a 2D</span>
<span class="sd">        DataArray or the alpha channel of a 3D DataArray. Valid</span>
<span class="sd">        strings are 'eq_hist' [default], 'cbrt' (cube root), 'log'</span>
<span class="sd">        (logarithmic), and 'linear'. Callables take 2 arguments - a</span>
<span class="sd">        2-dimensional array of magnitudes at each pixel, and a boolean</span>
<span class="sd">        mask array indicating missingness. They should return a numeric</span>
<span class="sd">        array of the same shape, with ``NaN`` values where the mask was</span>
<span class="sd">        True.</span>
<span class="sd">    alpha : int, optional</span>
<span class="sd">        Value between 0 - 255 representing the alpha value to use for</span>
<span class="sd">        colormapped pixels that contain data (i.e. non-NaN values).</span>
<span class="sd">        Also used as the maximum alpha value when alpha is indicating</span>
<span class="sd">        data value, such as for single colors or categorical plots.</span>
<span class="sd">        Regardless of this value, ``NaN`` values are set to be fully</span>
<span class="sd">        transparent when doing colormapping.</span>
<span class="sd">    min_alpha : float, optional</span>
<span class="sd">        The minimum alpha value to use for non-empty pixels when</span>
<span class="sd">        alpha is indicating data value, in [0, 255].  Use a higher value</span>
<span class="sd">        to avoid undersaturation, i.e. poorly visible low-value datapoints,</span>
<span class="sd">        at the expense of the overall dynamic range. Note that ``min_alpha``</span>
<span class="sd">        will not take any effect when doing discrete categorical coloring</span>
<span class="sd">        for 2D case as the aggregate can have only a single value to denote</span>
<span class="sd">        the category.</span>
<span class="sd">    span : list of min-max range, optional</span>
<span class="sd">        Min and max data values to use for 2D colormapping,</span>
<span class="sd">        and 3D alpha interpolation, when wishing to override autoranging.</span>
<span class="sd">    name : string name, optional</span>
<span class="sd">        Optional string name to give to the Image object to return,</span>
<span class="sd">        to label results for display.</span>
<span class="sd">    color_baseline : float or None</span>
<span class="sd">        Baseline for calculating how categorical data mixes to</span>
<span class="sd">        determine the color of a pixel. The color for each category is</span>
<span class="sd">        weighted by how far that category's value is above this</span>
<span class="sd">        baseline value, out of the total sum across all categories'</span>
<span class="sd">        values. A value of zero is appropriate for counts and for</span>
<span class="sd">        other physical quantities for which zero is a meaningful</span>
<span class="sd">        reference; each category then contributes to the final color</span>
<span class="sd">        in proportion to how much each category contributes to the</span>
<span class="sd">        final sum.  However, if values can be negative or if they are</span>
<span class="sd">        on an interval scale where values e.g. twice as far from zero</span>
<span class="sd">        are not twice as high (such as temperature in Farenheit), then</span>
<span class="sd">        you will need to provide a suitable baseline value for use in</span>
<span class="sd">        calculating color mixing.  A value of None (the default) means</span>
<span class="sd">        to take the minimum across the entire aggregate array, which</span>
<span class="sd">        is safe but may not weight the colors as you expect; any</span>
<span class="sd">        categories with values near this baseline will contribute</span>
<span class="sd">        almost nothing to the final color. As a special case, if the</span>
<span class="sd">        only data present in a pixel is at the baseline level, the</span>
<span class="sd">        color will be an evenly weighted average of all such</span>
<span class="sd">        categories with data (to avoid the color being undefined in</span>
<span class="sd">        this case).</span>
<span class="sd">    rescale_discrete_levels : boolean, optional</span>
<span class="sd">        If ``how='eq_hist`` and there are only a few discrete values,</span>
<span class="sd">        then ``rescale_discrete_levels=True`` decreases the lower</span>
<span class="sd">        limit of the autoranged span so that the values are rendering</span>
<span class="sd">        towards the (more visible) top of the ``cmap`` range, thus</span>
<span class="sd">        avoiding washout of the lower values.  Has no effect if</span>
<span class="sd">        ``how!=`eq_hist``. Default is False.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"agg must be instance of DataArray"</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">min_alpha</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"min_alpha (</span><span class="si">{}</span><span class="s2">) and alpha (</span><span class="si">{}</span><span class="s2">) must be between 0 and 255"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_alpha</span><span class="p">,</span><span class="n">alpha</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">rescale_discrete_levels</span> <span class="ow">and</span> <span class="n">how</span> <span class="o">!=</span> <span class="s1">'eq_hist'</span><span class="p">:</span>
        <span class="n">rescale_discrete_levels</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">color_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">color_key</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_apply_discrete_colorkey</span><span class="p">(</span>
                <span class="n">agg</span><span class="p">,</span> <span class="n">color_key</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">color_baseline</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_interpolate</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">min_alpha</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">rescale_discrete_levels</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_colorize</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">color_key</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">min_alpha</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">color_baseline</span><span class="p">,</span> <span class="n">rescale_discrete_levels</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"agg must use 2D or 3D coordinates"</span><span class="p">)</span></div>


<div class="viewcode-block" id="set_background"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.set_background">[docs]</a><span class="k">def</span> <span class="nf">set_background</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Return a new image, with the background set to `color`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : Image</span>
<span class="sd">    color : color name or tuple, optional</span>
<span class="sd">        The background color. Can be specified either by name, hexcode, or as a</span>
<span class="sd">        tuple of ``(red, green, blue)`` values.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Expected `Image`, got: `</span><span class="si">{0}</span><span class="s2">`"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)))</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>
    <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img</span>
    <span class="n">background</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">rgb</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">255</span><span class="p">,))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s1">'uint32'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">over</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">background</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="spread"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.spread">[docs]</a><span class="k">def</span> <span class="nf">spread</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">px</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">'circle'</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Spread pixels in an image.</span>

<span class="sd">    Spreading expands each pixel a certain number of pixels on all sides</span>
<span class="sd">    according to a given shape, merging pixels using a specified compositing</span>
<span class="sd">    operator. This can be useful to make sparse plots more visible.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : Image or other DataArray</span>
<span class="sd">    px : int, optional</span>
<span class="sd">        Number of pixels to spread on all sides</span>
<span class="sd">    shape : str, optional</span>
<span class="sd">        The shape to spread by. Options are 'circle' [default] or 'square'.</span>
<span class="sd">    how : str, optional</span>
<span class="sd">        The name of the compositing operator to use when combining</span>
<span class="sd">        pixels. Default of None uses 'over' operator for Image objects</span>
<span class="sd">        and 'add' operator otherwise.</span>
<span class="sd">    mask : ndarray, shape (M, M), optional</span>
<span class="sd">        The mask to spread over. If provided, this mask is used instead of</span>
<span class="sd">        generating one based on `px` and `shape`. Must be a square array</span>
<span class="sd">        with odd dimensions. Pixels are spread from the center of the mask to</span>
<span class="sd">        locations where the mask is True.</span>
<span class="sd">    name : string name, optional</span>
<span class="sd">        Optional string name to give to the Image object to return,</span>
<span class="sd">        to label results for display.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Expected `xr.DataArray`, got: `</span><span class="si">{0}</span><span class="s2">`"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)))</span>
    <span class="n">is_image</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">Image</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">px</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"``px`` must be an integer &gt;= 0"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">px</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">_mask_lookup</span><span class="p">[</span><span class="n">shape</span><span class="p">](</span><span class="n">px</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
              <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"mask must be a square 2 dimensional ndarray with "</span>
                         <span class="s2">"odd dimensions."</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">'bool'</span> <span class="k">else</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'bool'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">how</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">how</span> <span class="o">=</span> <span class="s1">'over'</span> <span class="k">if</span> <span class="n">is_image</span> <span class="k">else</span> <span class="s1">'add'</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="n">w</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">padded_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">extra</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">extra</span><span class="p">)</span>
    <span class="n">float_type</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
    <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">float_type</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Convert img.data to numpy array before passing to nb.jit kernels</span>
        <span class="n">img</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_image</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">_build_spread_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">is_image</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">float_type</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">_build_float_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">_build_int_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_kernel</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">padded_shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">kernel</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">buf</span><span class="p">[</span><span class="n">extra</span><span class="p">:</span><span class="o">-</span><span class="n">extra</span><span class="p">,</span> <span class="n">extra</span><span class="p">:</span><span class="o">-</span><span class="n">extra</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">apply_kernel</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">apply_kernel</span><span class="p">(</span><span class="n">img</span><span class="p">[:,:,</span><span class="n">category</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>

    <span class="k">return</span> <span class="n">img</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<span class="nd">@tz</span><span class="o">.</span><span class="n">memoize</span>
<span class="k">def</span> <span class="nf">_build_int_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">mask_size</span><span class="p">,</span> <span class="n">ignore_zeros</span><span class="p">):</span>
    <span class="sd">"""Build a spreading kernel for a given composite operator"""</span>
    <span class="n">validate_operator</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">is_image</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">composite_op_lookup</span><span class="p">[</span><span class="n">how</span> <span class="o">+</span> <span class="s2">"_arr"</span><span class="p">]</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">stencilled</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mask_size</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mask_size</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">ignore_zeros</span> <span class="ow">and</span> <span class="n">el</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span>
                            <span class="k">elif</span> <span class="n">ignore_zeros</span> <span class="ow">and</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">el</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">])</span>
                            <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">stencilled</span>


<span class="nd">@tz</span><span class="o">.</span><span class="n">memoize</span>
<span class="k">def</span> <span class="nf">_build_float_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">mask_size</span><span class="p">):</span>
    <span class="sd">"""Build a spreading kernel for a given composite operator"""</span>
    <span class="n">validate_operator</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">is_image</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">composite_op_lookup</span><span class="p">[</span><span class="n">how</span> <span class="o">+</span> <span class="s2">"_arr"</span><span class="p">]</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">stencilled</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mask_size</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mask_size</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">el</span><span class="p">):</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span>
                            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]):</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">el</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">])</span>
                            <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">stencilled</span>


<span class="nd">@tz</span><span class="o">.</span><span class="n">memoize</span>
<span class="k">def</span> <span class="nf">_build_spread_kernel</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">is_image</span><span class="p">):</span>
    <span class="sd">"""Build a spreading kernel for a given composite operator"""</span>
    <span class="n">validate_operator</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">is_image</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">composite_op_lookup</span><span class="p">[</span><span class="n">how</span> <span class="o">+</span> <span class="p">(</span><span class="s2">""</span> <span class="k">if</span> <span class="n">is_image</span> <span class="k">else</span> <span class="s2">"_arr"</span><span class="p">)]</span>

    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                <span class="c1"># Skip if data is transparent</span>
                <span class="n">process_image</span> <span class="o">=</span> <span class="n">is_image</span> <span class="ow">and</span> <span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">)</span> <span class="c1"># Transparent pixel</span>
                <span class="n">process_array</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_image</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">process_image</span> <span class="ow">or</span> <span class="n">process_array</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                            <span class="c1"># Skip if mask is False at this value</span>
                            <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">el</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                    <span class="n">result</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span>
                                <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                    <span class="n">result</span> <span class="o">=</span> <span class="n">el</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">])</span>
                                <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">kernel</span>


<span class="k">def</span> <span class="nf">_square_mask</span><span class="p">(</span><span class="n">px</span><span class="p">):</span>
    <span class="sd">"""Produce a square mask with sides of length ``2 * px + 1``"""</span>
    <span class="n">px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">px</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">px</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'bool'</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_circle_mask</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="sd">"""Produce a circular mask with a diameter of ``2 * r + 1``"""</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'i4'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>


<span class="n">_mask_lookup</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'square'</span><span class="p">:</span> <span class="n">_square_mask</span><span class="p">,</span>
                <span class="s1">'circle'</span><span class="p">:</span> <span class="n">_circle_mask</span><span class="p">}</span>


<div class="viewcode-block" id="dynspread"><a class="viewcode-back" href="../../api.html#datashader.transfer_functions.dynspread">[docs]</a><span class="k">def</span> <span class="nf">dynspread</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">max_px</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">'circle'</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Spread pixels in an image dynamically based on the image density.</span>

<span class="sd">    Spreading expands each pixel a certain number of pixels on all sides</span>
<span class="sd">    according to a given shape, merging pixels using a specified compositing</span>
<span class="sd">    operator. This can be useful to make sparse plots more visible. Dynamic</span>
<span class="sd">    spreading determines how many pixels to spread based on a density</span>
<span class="sd">    heuristic.  Spreading starts at 1 pixel, and stops when the fraction</span>
<span class="sd">    of adjacent non-empty pixels reaches the specified threshold, or</span>
<span class="sd">    the max_px is reached, whichever comes first.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : Image</span>
<span class="sd">    threshold : float, optional</span>
<span class="sd">        A tuning parameter in [0, 1], with higher values giving more</span>
<span class="sd">        spreading.</span>
<span class="sd">    max_px : int, optional</span>
<span class="sd">        Maximum number of pixels to spread on all sides.</span>
<span class="sd">    shape : str, optional</span>
<span class="sd">        The shape to spread by. Options are 'circle' [default] or 'square'.</span>
<span class="sd">    how : str, optional</span>
<span class="sd">        The name of the compositing operator to use when combining</span>
<span class="sd">        pixels. Default of None uses 'over' operator for Image objects</span>
<span class="sd">        and 'add' operator otherwise.</span>
<span class="sd">    """</span>
    <span class="n">is_image</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">Image</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"threshold must be in [0, 1]"</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_px</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">max_px</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"max_px must be &gt;= 0"</span><span class="p">)</span>
    <span class="c1"># Simple linear search. Not super efficient, but max_px is usually small.</span>
    <span class="n">float_type</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cupy</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Convert img.data to numpy array before passing to nb.jit kernels</span>
        <span class="n">img</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="n">px_</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">px</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_px</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">px_</span><span class="o">=</span><span class="n">px</span>
        <span class="k">if</span> <span class="n">is_image</span><span class="p">:</span>
            <span class="n">density</span> <span class="o">=</span> <span class="n">_rgb_density</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">px</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">density</span> <span class="o">=</span> <span class="n">_array_density</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">float_type</span><span class="p">,</span> <span class="n">px</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">img</span><span class="p">))</span> <span class="k">if</span> <span class="n">float_type</span> <span class="k">else</span> <span class="p">(</span><span class="n">img</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">flat_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masked</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'uint32'</span><span class="p">)</span>
            <span class="n">density</span> <span class="o">=</span> <span class="n">_array_density</span><span class="p">(</span><span class="n">flat_mask</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">px</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">density</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">px_</span><span class="o">=</span><span class="n">px_</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">px_</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spread</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">px_</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img</span></div>


<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_array_density</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">float_type</span><span class="p">,</span> <span class="n">px</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">"""Compute a density heuristic of an array.</span>

<span class="sd">    The density is a number in [0, 1], and indicates the normalized mean number</span>
<span class="sd">    of non-empty pixels that have neighbors in the given px radius.</span>
<span class="sd">    """</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">has_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
            <span class="n">el</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">float_type</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">el</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">float_type</span> <span class="ow">and</span> <span class="n">el</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>     <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">px</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">px</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">px</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">px</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="p">((</span><span class="n">float_type</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span> <span class="ow">or</span>
                            <span class="p">(</span><span class="ow">not</span> <span class="n">float_type</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)):</span>
                            <span class="n">neighbors</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">neighbors</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># (excludes self)</span>
                    <span class="n">has_neighbors</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">has_neighbors</span><span class="o">/</span><span class="n">cnt</span> <span class="k">if</span> <span class="n">cnt</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>


<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_rgb_density</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">px</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">"""Compute a density heuristic of an image.</span>

<span class="sd">    The density is a number in [0, 1], and indicates the normalized mean number</span>
<span class="sd">    of non-empty pixels that have neighbors in the given px radius.</span>
<span class="sd">    """</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">has_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>     <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">px</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">px</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">px</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">px</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">:</span>
                            <span class="n">neighbors</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">neighbors</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># (excludes self)</span>
                    <span class="n">has_neighbors</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">has_neighbors</span><span class="o">/</span><span class="n">cnt</span> <span class="k">if</span> <span class="n">cnt</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
</pre></div>
</div>
<!-- Previous / next buttons -->
<div class="prev-next-area">
</div>
</main>
</div>
</div>
<!-- Scripts loaded after <body> so the DOM is not blocked -->
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
<div class="container">
<div class="footer-item">
<p class="nbsite-copyright-last-updated">
<span class="copyright">
            Â© Copyright 2016-2022 Holoviz contributors.
    </span>
<span class="last-updated">Last updated on 2022-04-25.</span><br/>
</p>
</div>
</div>
</footer>
</body>
</html>